# ElGamal

Distributed Lab course

Завдання полягало у власній реалізації алгоритмів цифрового підпису та шифрування використовуючи схему Ель Гамаля. 

Для цифрового підпису реалізовано наступні функції:
+ GenKey() (p, g, a, b *big.Int) - генерує просте число p, первісний корінь який є генератором g та секретний і публічний ключі a та b відповідно
+ Sign(m string, p, g, a *big.Int) (r, s *big.Int) - приймає рядок тексту m(невдовзі буде перероблено під масив байт), p та g, і секретний ключ a - на виході повертає підпис (r, s)
+ Verify(m string, p, g, b, r, s *big.Int) bool - приймає рядок тексту m(невдовзі буде перероблено під масив байт), p та g, і секретний ключ b, підпис (r, s) - на виході повертає булеве значення true або false

Для шифрування було реалізовано наступні функції:
+ GenKey() (p, g, a, b *big.Int) - так само як і в підписі генерує ключі
+ EncryptPart(M []byte, p, g, y, q *big.Int) (a, b *big.Int) - шифрує один блок повідомлення довжиною до 64 байт
+ Encrypt(M []byte, p, g, y *big.Int) (enc []\[2]*big.Int) - шифрує повідомлення приймаючи на вхід саме повідомлення M, параметри системи p і g, а також публічний ключ y - повертає масив пар значень що і є шифротекстом
+ DecryptPart(a, b, x, p, q *big.Int) []byte - дешифрує один блок повідомлення довжиною до 64 байт
+ Decrypt(enc [][2]*big.Int, x, p *big.Int) []byte - дешифрує повідомлення приймаючи на вхід шифротекст, параметри системи p і g, а також секретний ключ x - повертає масив байт


Тестування реалізацій:
![image](https://github.com/Zaptoss/Cryptography-for-Developers/assets/57064743/0f89e426-6f5a-4a34-9f99-964e34a1c646)
